C51 COMPILER V9.60.0.0   FLOOR                                                             05/15/2021 18:01:58 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE FLOOR
OBJECT MODULE PLACED IN .\Objects\floor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Mid\floor.c LARGE OPTIMIZE(0,SPEED) BROWSE INCDIR(..\App;..\Common;..
                    -\Driver;..\Mid;..\Utilities) DEBUG OBJECTEXTEND PRINT(.\Listings\floor.lst) OBJECT(.\Objects\floor.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_Define.h"
   4          #include "adc.h"
   5          #include "relay.h"
   6          #include "delay.h"
   7          #include "floor.h"
   8          
   9          extern uint16_t topLimitFloor;
  10          extern uint16_t botLimitFloor;
  11          uint16_t adc_retval[12];
  12          
  13          #define STEP ((topLimitFloor - botLimitFloor) / 12)
  14          #define DELTA  (6)
  15          
  16          static void get_adc_levels()
  17          {
  18   1          int i;
  19   1          for ( i = 0; i < 12; i++)
  20   1          {
  21   2              adc_retval[i] = botLimitFloor + i * STEP;
  22   2          }
  23   1      }
  24          
  25          int FLOOR_UpOrDown(uint16_t desireIncl)
  26          {
  27   1          int i;
  28   1          uint16_t resutlAdc;
  29   1          directionFloor_t dir = F_DEFAULT;
  30   1          uint16_t incline_level[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
  31   1          /* Check input*/
  32   1          if(desireIncl < 1 | desireIncl > 12)
  33   1          {
  34   2              return -1;
  35   2          }
  36   1          /* Get adc value levels base on top limit and bottom limit*/
  37   1          get_adc_levels();
  38   1      
  39   1          /* Convert incline from desire Level to adc value*/
  40   1          for (i = 0; i < 12; i++)
  41   1          {
  42   2              if (desireIncl == incline_level[i])
  43   2              {
  44   3                  desireIncl = adc_retval[i];
  45   3                  break;
  46   3              }
  47   2          }
  48   1          /* Get current value of adc*/
  49   1          resutlAdc = readResultConvert();
  50   1          /*  Check Incline will increase or decrease*/
  51   1          if ( resutlAdc <  desireIncl - DELTA)
  52   1          {
  53   2              dir = F_UP;
  54   2          }
C51 COMPILER V9.60.0.0   FLOOR                                                             05/15/2021 18:01:58 PAGE 2   

  55   1          else if( resutlAdc >= ( desireIncl - DELTA ) && resutlAdc <= ( desireIncl + DELTA ))
  56   1          {
  57   2              return 0;
  58   2          }
  59   1          else
  60   1          {
  61   2              dir = F_DOWN;
  62   2          }
  63   1      
  64   1          switch (dir)
  65   1          {
  66   2          case F_UP:
  67   2              RELAY_DownReset();
  68   2              delay_ms(100);
  69   2              RELAY_Up();
  70   2              do
  71   2              {
  72   3                  resutlAdc = readResultConvert();
  73   3              } while (resutlAdc < (desireIncl - DELTA) || resutlAdc > (desireIncl + DELTA));
  74   2      
  75   2              /* Reach desireIncl*/
  76   2              RELAY_UpReset();
  77   2              delay_ms(100);
  78   2              break;
  79   2          case F_DOWN:
  80   2              RELAY_UpReset();
  81   2              delay_ms(100);
  82   2              RELAY_Down();
  83   2              do
  84   2              {
  85   3                  resutlAdc = readResultConvert();
  86   3              } while (resutlAdc < (desireIncl - DELTA) || resutlAdc > (desireIncl + DELTA));
  87   2      
  88   2              /* Reach desireIncl*/
  89   2              RELAY_DownReset();
  90   2              delay_ms(100);
  91   2              break;
  92   2          default:
  93   2              return 0;
  94   2              break;
  95   2          }
  96   1          /* Start run*/
  97   1          return 0;
  98   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    719    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =     57    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
