C51 COMPILER V9.60.0.0   FLOOR                                                             06/20/2021 15:27:14 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE FLOOR
OBJECT MODULE PLACED IN .\Objects\floor.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\Mid\floor.c LARGE OPTIMIZE(0,SPEED) BROWSE INCDIR(..\App;..\Common;..
                    -\Driver;..\Mid;..\Utilities) DEBUG OBJECTEXTEND PRINT(.\Listings\floor.lst) OBJECT(.\Objects\floor.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_Define.h"
   4          #include "adc.h"
   5          #include "gpio.h"
   6          #include "relay.h"
   7          #include "delay.h"
   8          #include "timer.h"
   9          #include "floor.h"
  10          
  11          uint16_t topLimitFloor;
  12          uint16_t botLimitFloor;
  13          uint16_t adc_retval[12];
  14          uint16_t resutlAdc;
  15          extern boolen_t firstTime;
  16          
  17          #define DELTA (topLimitFloor - botLimitFloor)
  18          #define ERR  (2)
  19          
  20          static void get_adc_levels()
  21          {
  22   1          int i;
  23   1          for ( i = 0; i < 12; i++)
  24   1          {
  25   2              adc_retval[i] = botLimitFloor + ( i * DELTA) / 12;
  26   2          }
  27   1      }
  28          
  29          static void FLOOR_GetTopAndBotLimitValue(void)
  30          {
  31   1      
  32   1          uint16_t newValue = 0;
  33   1          uint16_t tempValue = 0;
  34   1      
  35   1          if (firstTime == YES)
  36   1          {
  37   2              firstTime = NO;
  38   2          }
  39   1          
  40   1          RELAY_Up();
  41   1          newValue = ADC_ReadResultConvert();
  42   1          while (tempValue != newValue)
  43   1          {
  44   2              tempValue = newValue;
  45   2              delay_us(1000);
  46   2              newValue = ADC_ReadResultConvert();
  47   2          }
  48   1          RELAY_UpReset();
  49   1          topLimitFloor = tempValue;
  50   1          delay_ms(1000);
  51   1      
  52   1          tempValue = 0;
  53   1          RELAY_Down();
  54   1          //newValue = ADC_ReadResultConvert();
C51 COMPILER V9.60.0.0   FLOOR                                                             06/20/2021 15:27:14 PAGE 2   

  55   1          while (tempValue != newValue)
  56   1          {
  57   2              tempValue = newValue;
  58   2              delay_us(1000);
  59   2              newValue = ADC_ReadResultConvert();
  60   2          }
  61   1          RELAY_DownReset();
  62   1          botLimitFloor = tempValue;
  63   1      }
  64          
  65          void FLOOR_Init(void)
  66          {
  67   1          ADC_Init();
  68   1          GPIO_CallBackInit(FLOOR_GetTopAndBotLimitValue);
  69   1      }
  70          
  71          int FLOOR_UpOrDown(uint16_t desireIncl)
  72          {
  73   1          int i;
  74   1          directionFloor_t dir = F_DEFAULT;
  75   1          uint16_t incline_level[12] = {1,2,3,4,5,6,7,8,9,10,11,12};
  76   1          /* Check input*/
  77   1          if(desireIncl < 1 | desireIncl > 12)
  78   1          {
  79   2              return -1;
  80   2          }
  81   1          /* Get adc value levels base on top limit and bottom limit*/
  82   1          get_adc_levels();
  83   1      
  84   1          /* Convert incline from desire Level to adc value*/
  85   1          for (i = 0; i < 12; i++)
  86   1          {
  87   2              if (desireIncl == incline_level[i])
  88   2              {
  89   3                  desireIncl = adc_retval[i];
  90   3                  break;
  91   3              }
  92   2          }
  93   1          /* Get current value of adc*/
  94   1          resutlAdc = ADC_ReadResultConvert();
  95   1          /*  Check Incline will increase or decrease*/
  96   1          if ( resutlAdc <  desireIncl) {
  97   2              dir = F_UP;
  98   2          }
  99   1          else if( resutlAdc >= ( desireIncl - ERR ) && resutlAdc <= ( desireIncl + ERR )) {
 100   2              return 0;
 101   2          }
 102   1          else {
 103   2              dir = F_DOWN;
 104   2          }
 105   1      
 106   1          switch (dir) {
 107   2          case F_UP:
 108   2              RELAY_DownReset();
 109   2              delay_ms(10);
 110   2              RELAY_Up();
 111   2              do {
 112   3                  resutlAdc = ADC_ReadResultConvert();
 113   3              } while (resutlAdc < desireIncl - ERR);
 114   2      
 115   2              /* Reach desireIncl*/
 116   2              RELAY_UpReset();
C51 COMPILER V9.60.0.0   FLOOR                                                             06/20/2021 15:27:14 PAGE 3   

 117   2              break;
 118   2          case F_DOWN:
 119   2              RELAY_UpReset();
 120   2              delay_ms(10);
 121   2              RELAY_Down();
 122   2              do {
 123   3                  resutlAdc = ADC_ReadResultConvert();
 124   3              } while (resutlAdc > desireIncl + ERR);
 125   2      
 126   2              /* Reach desireIncl*/
 127   2              RELAY_DownReset();
 128   2              break;
 129   2          default:
 130   2              return 0;
 131   2              break;
 132   2          }
 133   1          /* Start run*/
 134   1          return 0;
 135   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    873    ----
   CONSTANT SIZE    =     24    ----
   XDATA SIZE       =     65    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
